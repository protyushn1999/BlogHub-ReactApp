{
  "blogs": [
    {
      "title": "How to learn recursion??",
      "body": "Recursion is a tool not often used by imperative language developers because it is thought to be slow and to waste space. But as you'll see, there are several techniques that can be used to minimize or eliminate these problems. This article introduces the concept of recursion and tackles recursive programming patterns, examining how they can be used to write provably correct programs. Examples are in Scheme and C.\n\nFor new computer science students, the concept of recursive programming is often difficult. Recursive thinking is difficult because it almost seems like circular reasoning. It's also not an intuitive process; when we give instructions to other people, we rarely direct them recursively.\n\nFor those of you who are new to computer programming, here's a simple definition of recursion: Recursion occurs when a function calls itself directly or indirectly.\n\nA classic example of recursion\nThe classic example of recursive programming involves computing factorials. The factorial of a number is computed as that number times all of the numbers below it up to and including 1. For example, factorial(5) is the same as 5*4*3*2*1, and factorial(3) is 3*2*1.\n\nAn interesting property of a factorial is that the factorial of a number is equal to the starting number multiplied by the factorial of the number immediately below it. For example, factorial(5) is the same as 5 * factorial(4). You could almost write the factorial function simply as this:\n\nListing 1. First try at factorial function\nint factorial(int n)\n{\n   return n * factorial(n ‑ 1);\n}\n\nShow more\nThe problem with this function, however, is that it would run forever because there is no place where it stops. The function would continually call factorial. There is nothing to stop it when it hits zero, so it would continue calling factorial on zero and the negative numbers. Therefore, our function needs a condition to tell it when to stop.\n\nSince factorials of numbers less than 1 don't make any sense, we stop at the number 1 and return the factorial of 1 (which is 1). Therefore, the real factorial function will look like this:\n\nListing 2. Actual factorial function\nint factorial(int n)\n{\n   if(n == 1)\n   {\n      return 1;\n   }\n   else\n   {\n      return n * factorial(n ‑ 1);\n   }\n}\n\nShow more\nAs you can see, as long as the initial value is above zero, this function will terminate. The stopping point is called the base case. A base case is the bottom point of a recursive program where the operation is so trivial as to be able to return an answer directly. All recursive programs must have at least one base case and must guarantee that they will hit one eventually; otherwise the program would run forever or until the program ran out of memory or stack space.\n\nBasic steps of recursive programs\nEvery recursive program follows the same basic sequence of steps:\n\nInitialize the algorithm. Recursive programs often need a seed value to start with. This is accomplished either by using a parameter passed to the function or by providing a gateway function that is nonrecursive but that sets up the seed values for the recursive calculation.\nCheck to see whether the current value(s) being processed match the base case. If so, process and return the value.\nRedefine the answer in terms of a smaller or simpler sub-problem or sub-problems.\nRun the algorithm on the sub-problem.\nCombine the results in the formulation of the answer.\nReturn the results.\nUsing an inductive definition\nSometimes when writing recursive programs, finding the simpler sub-problem can be tricky. Dealing with inductively-defined data sets, however, makes finding the sub-problem considerably easier. An inductively-defined data set is a data structure defined in terms of itself -- this is called an inductive definition.\n\nFor example, linked lists are defined in terms of themselves. A linked list consists of a node structure that contains two members: the data it is holding and a pointer to another node structure (or NULL, to terminate the list). Because the node structure contains a pointer to a node structure within it, it is said to be defined inductively.\n\nWith inductive data, it is fairly easy to write recursive procedures. Notice how like our recursive programs, the definition of a linked list also contains a base case -- in this case, the NULL pointer. Since a NULL pointer terminates a list, we can also use the NULL pointer condition as a base case for many of our recursive functions on linked lists.\n\nLinked list example\nLet's look at a few examples of recursive functions on linked lists. Suppose we have a list of numbers, and we want to sum them. Let's go through each step of the recursive sequence and identify how it applies to to our summation function:\n\nInitialize the algorithm. This algorithm's seed value is the first node to process and is passed as a parameter to the function.\nCheck for the base case. The program needs to check and see if the current node is the NULL list. If so, we return zero because the sum of all members of an empty list is zero.\nRedefine the answer in terms of a simpler sub-problem. We can define the answer as the sum of the rest of the list plus the contents of the current node. To determine the sum of the rest of the list, we call this function again with the next node.\nCombine the results. After the recursive call completes, we add the value of the current node to the results of the recursive call.\nHere is the pseudo-code and the real code for the function:\n\nListing 3. Pseudo-code for the sum_list program\n function sum_list(list l)\n    is l null?\n       yes ‑ the sum of an empty list is 0 ‑ return that\n    data = head of list l\n    rest_of_list = rest of list l\n    the sum of the list is:\n       data + sum_list(rest_of_list)\n\nShow more\nThe pseudo-code for this program almost identically matches its Scheme implementation.\n\nListing 4. Scheme code for the sum_list program\n (define sum‑list (lambda (l)\n    (if (null? l)\n       0\n       (let (\n             (data (car l))\n             (rest‑of‑list (cdr l)))\n          (+ data (sum‑list rest‑of‑list))))))\n\nShow more\nFor this easy example, the C version is just as simple.\n\nListing 5. C code for the sum_list program\nint sum_list(struct list_node *l)\n{\n   if(l == NULL)\n      return 0;\n    return l.data + sum_list(l.next);\n}\n\nShow more\nYou may be thinking that you know how write this program to perform faster or better without recursion. We will get to the speed and space issues of recursion later on. In the meantime, let's continue our discussion of recursing of inductive data sets.\n\nSuppose we have a list of strings and want to see whether a certain string is contained in that list. The way to break this down into a simpler problem is to look again at the individual nodes.\n\nThe sub-problem is this: \"Is the search string the same as the one in this node?\" If so, you have your solution; if not, you are one step closer. What's the base case? There are two:\n\nIf the current node has the string, that's a base case (returning \"true\").\nIf the list is empty, then that's a base case (returning \"false\").\nThis program won't always hit the first base case because it won't always have the string being searched for. However, we can be certain that if the program doesn't hit the first base case it will at least hit the second one when it gets to the end of the list.\n\nListing 6. Scheme code for determining if a given list contains a given string\n(define is‑in‑list\n    (lambda   (the‑list the‑string)\n       ;;Check for base case of \"list empty\"\n       (if (null? the‑list)\n          #f\n          ;;Check for base case of \"found item\"\n          (if (equal? the‑string (car the‑list))\n             #t\n             ;;Run the algorithm on a smaller problem\n             (is‑in‑list (cdr the‑list) the‑string)))))\n\nShow more\nThis recursive function works fine, but it has one main shortcoming -- every iteration of the recursion will be passing the same value for the-string. Passing the extra parameter can increase the overhead of the function call.\n\nHowever, we can set up a closure at the beginning of the function to keep the string from having to be passed on each call:\n\nListing 7. Scheme program for finding a string using a closure\n (define is‑in‑list2\n    (lambda (the‑list the‑string)\n       (letrec\n         (\n              (recurse (lambda (internal‑list)\n                   (if (null? internal‑list)\n                      #f\n                      (if (equal? the‑string (car internal‑list))\n                         #t\n                         (recurse (cdr internal‑list)))))))\n          (recurse the‑list))))\n\nShow more\nThis version of the program is a little harder to follow. It defines a closure called recurse that can be called with only one parameter rather than two. (For more information on closures, see resouces on the right side.) We don't need to pass in the-string to recurse because it is already in the parent environment and does not change from call to call. Because recurse is defined within the is-in-list2 function, it can see all of the currently defined variables, so they don't need to be re-passed. This shaves off one variable being passed at each iteration.\n\nUsing a closure instead of passing the parameter doesn't make a lot of difference in this trivial example, but it can save a lot of typing, a lot of errors, and a lot of overhead involved in passing variables in more complex functions.\n\nThe way of making recursive closures used in this example is a bit tedious. This same pattern of creating a recursive closure using letrec and then calling it with an initial seed value occurs over and over again in recursive programming.\n\nIn order to make programming recursive patterns easier, Scheme contains a shortcut called the named let. This construct looks a lot like a let except that the whole block is given a name so that it can be called as a recursive closure. The parameters of the function built with the named let are defined like the variables in a regular let; the initial seed values are set the same way initial variable values are set in a normal let. From there, each successive recursive call uses the parameters as new values.\n\nNamed let's are fairly confusing to talk about, so take a look at the following code and compare it with the code in Listing 7.\n\nListing 8. Named let example\n\nListing 8. Named let example\n(define is‑in‑list2\n    (lambda (the‑list the‑string)\n       ;;Named Let\n       ;;This let block defines a function called \"recurse\" that is the\n      ;;body of this let.  The function's parameters are the same as\n       ;;the variables listed in the let.\n       (let recurse\n          ;;internal‑list is the first and only parameter.  The\n          ;;first time through the block it will be primed with\n          ;;\"the‑list\" and subsequent calls to \"recurse\" will\n          ;;give it whatever value is passed to \"recurse\"\n          ( (internal‑list the‑list) )\n\n          ;;Body of function/named let block\n          (if (null? internal‑list)\n             #f\n             (if (equal? the‑string (car internal‑list))\n                #t\n                ;;Call recursive function with the\n                ;;rest of the list\n                (recurse (cdr internal‑list)))))))\n\nShow more\nThe named let cuts down considerably on the amount of typing and mistakes made when writing recursive functions. If you are still having trouble with the concept of named lets, I suggest that you thoroughly compare every line in the above two programs (as well as look at some of the documents in the resouces on the right side of this article).\n\nOur next example of a recursive function on lists will be a little more complicated. It will check to see whether or not a list is in ascending order. If the list is in ascending order, the function will return #t; otherwise, it will return #f. This program will be a little different because in addition to having to examine the current value, we will also have to remember the last value processed.\n\nThe first item on the list will have to be processed differently than the other items because it won't have any items preceding it. For the remaining items, we will need to pass the previously examined data item in the function call. The function looks like this:\n\nListing 9. Scheme program to determine whether a list is in ascending order\n(define is‑ascending\n    (lambda (the‑list)\n       ;;First, Initialize the algorithm.  To do this we\n       ;;need to get the first value, if it exists, and\n       ;;use it as a seed to the recursive function\n       (if (null? the‑list)\n          #t\n          (let is‑ascending‑recurse\n             (\n                 (previous‑item (car the‑list))\n                (remaining‑items (cdr the‑list))\n             )\n             ;;Base case #1 ‑ end of list\n             (if (null? remaining‑items)\n                #t\n                (if (< previous‑item (car remaining‑items))\n                   ;;Recursive case, check the rest of the list\n                   (is‑ascending‑recurse (car remaining‑items) (cdr remaining‑items))\n                   ;;Base case #2 ‑ not in ascending order\n                   #f))))))\n\nShow more\nThis program begins by first checking a boundary condition -- whether or not the list is empty. An empty list is considered ascending. The program then seeds the recursive function with the first item on the list and the remaining list.\n\nNext, the base case is checked. The only way to get to the end of the list is if everything so far has been in order, so if the list is empty, the list is in ascending order. Otherwise, we check the current item.\n\nIf the current item is in ascending order, we then have only a subset of the problem left to solve -- whether or not the rest of the list is in ascending order. So we recurse with the rest of the list and try it again.\n\nNotice in this function how we maintained state through function calls by passing the program forward. Previously we had just passed the remainder of the list each time. In this function though, we needed to know a little bit more about the state of the computation. The result of the present computation depended on the partial results before it, so in each successive recursive call, we pass those results forward. This is a common pattern for more complex recursive procedures.\n\nWriting provably correct programs\nBugs are a part of the daily life of every programmer because even the smallest loops and the tiniest function calls can have bugs in them. And while most programmers can examine code and test code for bugs, they do not know how to prove that their programs will perform the way they think they will. With this in mind, we are going to examine some of the common sources of bugs and then demonstrate how to make programs which are correct and can be proven so.\n\nBug source: State changes\nOne of the primary sources of bugs occurs when variables change states. You might think that the programmer would be keenly aware of exactly how and when a variable changes state. This is sometimes true in simple loops, but usually not in complex ones. Usually within loops, there are several ways that a given variable can change state.\n\nFor example, if you have a complicated if statement, some branches may modify one variable while others modify other variables. On top of that, the order is usually important but it is difficult to be absolutely sure that the sequence coded is the correct order for all cases. Often, fixing one bug for one case will introduce other bugs in other cases because of these sequencing issues.\n\nIn order to prevent these kinds of errors, a developer needs to be able to:\n\nTell by sight how each variable received its present value.\nBe certain that no variable is performing double-duty. (Many programmers often use the same variable to store two related but slightly different values.)\nBe certain that all variables hit the state they are supposed to be in when the loop restarts. (A common programming error is failure to set new values for loop variables in corner cases that are rarely used and tested.)\nTo accomplish these objectives, we need to make only one rule in our programming: Assign a value to a variable only once and NEVER MODIFY IT!\n\nWhat? (You say increduluously!) This rule is blasphemy for many who have been raised on imperative, procedural, and object-oriented programming -- variable assignment and modification are at the core of these programming techniques! Still, state changes are consistently one of the chief causes for programming errors for imperative programmers.\n\nSo how does a person program without modifying variables? Let's look at several situations in which variables are often modified and see if we can get by without doing so:\n\nReusing a variable.\nConditional modification of a variable.\nLoop variables.\nLet's examine the first case, reusing a variable. Often, a variable is reused for different, but similar, purposes. For example, sometimes if part of a loop needs an index to the current position in the first half of a loop and the index immediately before or after for the rest of the loop, many programmers use the same variable for both cases, just incrementing it in the middle. This can easily cause the programmer to confuse the two uses as the program is modified. To prevent this problem, the best solution is to create two separate variables and just derive the second from the first the same way you would do so if you were just writing to the same variable.\n\nThe second case, the conditional modification of a variable, is a subset of the variable reuse problem except that sometimes we will keep our existing value and sometimes we will want a new value. Again, the best thing is to create a new variable. In most languages, we can use the tertiary operator ? : to set the value of the new variable. For example, if we wanted to give our new variable a new value, as long as it's not greater than some_value, we could write int new_variable = old_variable > some_value ? old variable : new_value;.\n\n(We'll discuss loop variables later in the article.)\n\nOnce we have rid ourselves of all variable state changes, we can know that when we first define our variable, the definition of our variable will hold for as long as the function lasts. This makes sequencing orders of operations much easier, especially when modifying existing code. You don't have to worry about what sequence a variable might have been modified in or what assumptions were being made about its state at each juncture.\n\nWhen a variable cannot change state, the full definition of how it is derived is illustrated when and where it is declared! You never have to go searching through code to find the incorrect or misordered state change again!\n\n",
      "author": "Protyush",
      "id": 1
    },
    {
      "title": "How to master backtracking??",
      "body": "Understand the problem: Make sure you understand the problem and the constraints before starting to write code.\n\nBreak the problem into subproblems: Identify the subproblems that make up the larger problem and solve them one by one.\n\nWrite a recursive function: Write a recursive function that takes the current state of the problem as an input and returns a solution if one exists.\n\nImplement backtracking: In the recursive function, use backtracking to explore different possibilities and undo choices that lead to dead-ends.\n\nUse pruning techniques: Use techniques such as early termination and bounds checking to eliminate unnecessary branches and speed up the algorithm.\n\nTest and debug: Test your code thoroughly and use debugging tools to identify and fix any errors.\n\nPractice: Practice solving different problems using backtracking to improve your understanding and skills.",
      "author": "ChatGPT",
      "id": 2
    }
  ]
}